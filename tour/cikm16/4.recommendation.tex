%!TEX root = main.tex

\secmoveup
\section{Tour Recommendation}
\label{sec:recommendation}

In this section, we first describe the recommendation of points and routes,
then we discuss how to combine them, and finally we propose a method to avoid sub-tours.

\secmoveup
\subsection{POI Ranking and Route Planning}
\label{sec:rankplan}
%\secmoveup

A naive approach would be to recommend trajectories based on the popularity of POIs only,
that is we always suggest the top-$k$ most popular POIs for all visitors given the start and end location.
We call this baseline approach \textsc{PoiPopularity},
and its only adaptation to a particular query is to adjust $k$ to match the desired length.

On the other hand, we can leverage the whole set of POI features described in Section~\ref{sec:feature}
to learn a ranking of POIs using rankSVM, with linear kernel and L$2$ loss~\cite{lranksvm},
\eqmoveup
\begin{equation*}
\eqmoveup
\min_{\mathbf{w}} \frac{1}{2}
                  \mathbf{w}^T \mathbf{w} +
                  \underset{p_i, p_j \in \mathcal{P},~ q \in \mathcal{Q}}{C ~\sum}
                  \max \left( 0,~ 1 - \mathbf{w}^T (\phi_{i,q} - \phi_{j,q}) \right)^2,
\end{equation*}
%%LX: remove subscript n, and index \phi by q 
%% to simplify, and be consistent w. Sec 3.2 
where $\mathbf{w}$ is the parameter vector,
$C > 0$ is a regularisation constant,
$\mathcal{P}$ is the set of POIs to rank,
$\mathcal{Q}$ denotes the queries corresponding to trajectories in training set,
and $\phi_{i,q}$ is the feature vector for POI $p_i$ with respect to query $q$. %\in \mathcal{Q}$. 
The ranking score of $p_i$ given query $q$ is computed as $R_{i,q} =\mathbf{w}^T \phi_{i,q}$. 

For training the rankSVM, the labels are generated using the number of occurrences of
POI $p$ in trajectories grouped by query $(p_s, p_e, L)$,
without counting the occurrence of $p$ when it is the origin or destination of a trajectory.
Our algorithm, \textsc{PoiRank}, recommends a trajectory for a particular query
by first ranking POIs
%utilising both POI and query specific features described above.
%\textsc{PoiRank}
then takes the top ranked $L-2$ POIs and connects them according to the ranks.



%\subsection{Route Planning}
%\label{sec:markov}

In addition to recommend trajectory by ranking POIs, we can leverage the POI-POI transition probabilities and
recommend a trajectory (with respect to a query) by maximising the transition likelihood.
The maximum likelihood of the Markov chain of transitions is found using a variant of the Viterbi algorithm (with uniform emission probabilities).
We call this approach that only uses the transition probabilities between POIs as \textsc{Markov}.

%which is shown in Algorithm~\ref{alg:markov}.
%The entry $A[l, p]$ in score matrix $A$ stores the maximum likelihood associated with the (partial) trajectory
%that starts from $p_s$ and ends at $p$ with $l$ POI visits,
%and entry $B[l, p]$ in the backtracking-point matrix $B$ stores the predecessor of $p$ in that (partial) trajectory.


\secmoveup
\subsection{Combine Ranking and Transition}
\label{sec:rank+markov}


%\subsection{POI ranking and transitions}
%\label{sec:rank+markov}

%Instead of recommend trajectory by either ranking POIs or planning routes with regard to POI-POI transition probabilities,
%To recommend the \textit{most likely} trajectory with respect to a query,
%we want to combine the ranking of POIs with the transition probabilities,
We would like to leverage both point ranking and transitions,
i.e., recommending a trajectory that maximises the points ranking of its POIs as well as its transition likelihood at the same time.
To begin with, we transform the ranking scores $R_{j,q}$ of POI $p_j$ with respect to query $q$
to a probability distribution using the softmax function,
%~\cite{bishop2006},
\eqmoveup
\begin{equation}
\eqmoveup
\label{eq:rankprob}
P_R(p_j | q) = \frac{\exp(R_{j,q})}{\sum_i \exp(R_{i,q})},
\end{equation}
%%LX: summation subscript bug, and R_jq already defined in Sec 3.1 
%where $R_j$ is the ranking score of POI $p_j$ from rankSVM.
%  \item Heuristics: \textsc{Rank+Markov}, \textsc{Rank+MarkovPath}
One option to find a trajectory that simultaneously maximises the ranking probabilities of its POIs and its transition likelihood is to optimise the following objective:
%%LX - removing j to avoid subscript of subscript, 
%% seems we don't need it here, and nowhere else in this paper do we really need it
\eqmoveup
\vspace{-0.3em}
\begin{equation*}\eqmoveup
    \argmax_{\mathcal{T} \in \mathcal{P}^L} ~\alpha \sum_{k=2}^{L} \log P_R(p_{k} | q) +
                                     (1-\alpha) \sum_{k=1}^{L-1} \log P(p_{k+1} | p_{k}),
\end{equation*}
such that
$p_{1} = p_s, ~ p_{L} = p_e$ and
$p_{k} \in \mathcal{P}, ~1 \le k \le L$.
The first term captures the POI ranking, and the second one incorporates the transition probabilities.
$\mathcal{T} = (p_{1}, \dots, p_{L})$ is any possible trajectory,
$\alpha \in [0, 1]$ is a parameter to trade-off the importance between point ranking and transition,
%of POIs and the POI-POI transitions in the recommended trajectory,
and can be tuned using cross validation in practice.
%Similar to the \textsc{Markov} algorithm mentioned above,
Let $S(p; p', q)$ be a convex combination of point ranking and transition,
\eqmoveup
\vspace{-0.3em}
\begin{equation}\label{eq:combined-score}
    S(p; p', q)  = \alpha \log P_R(p|q) + (1-\alpha) \log P(p|p'),
\end{equation}
then the best path (or walk) can be found using the Viterbi algorithm.
We call this approach that uses both the points ranking and transitions \textsc{Rank+Markov},
with pseudo code shown in Algorithm~\ref{alg:rank+markov},
%as shown in lines~\ref{eq:max} and~\ref{eq:argmax} in Algorithm~\ref{alg:rank+markov}.
%with both node and transition scores.
%The objective can be optimised by adapting the Viterbi algorithm and using the two recursions below,
%A[l+1, p] = \max_{p' \in \mathcal{P}} \{ A[l, p'] + \alpha \log P_R(p|q) \\ + (1-\alpha) \log P(p|p') \}
%B[l+1, p] = \argmax_{p' \in \mathcal{P}} \{ A[l, p'] + \alpha \log P_R(p|q) \\ + (1-\alpha) \log P(p|p') \}
%\eqmoveup
%\begin{alignat}{2}\eqmoveup
%&A[l+1, p]   &&= \max_{p' \in \mathcal{P}} \{ A[l, p'] + S(p; p', q) \}, \label{eq:max} \\
%&B[l+1, p]   &&= \argmax_{p' \in \mathcal{P}} \{ A[l, p'] + S(p; p', q) \}, \label{eq:argmax}
%\end{alignat}
where $A$ is the score matrix, and entry $A[l, p]$ stores the maximum value associated with the (partial) trajectory
that starts at $p_s$ and ends at $p$ with $l$ POI visits;
$B$ is the backtracking-point matrix, and entry $B[l, p]$ stores the predecessor of $p$ in that (partial) trajectory.
The maximum objective value is $A[L, p_e]$,
and the corresponding trajectory can be found by tracing back from $B[L, p_e]$.

\setlength{\textfloatsep}{0.5em} % reduce \textfloatsep for float algorithm

\begin{algorithm}[t]
\caption{\textsc{Rank+Markov}: recommend trajectory with POI ranking and transition}
\label{alg:rank+markov}
\begin{algorithmic}[1]
\STATE \textbf{Input}: $\mathcal{P}, p_s, p_e, L$
\STATE \textbf{Output}: Trajectory $\mathcal{T} = (p_s, \cdots, p_e)$ with $L$ POIs
%\STATE Compute a rank $<_{p_i, p_j} \subset \mathcal{P}^2$ w.r.t. query $q = (p_s, p_e, L)$
%\STATE Compute POI-POI transition matrix
\STATE Initialise score matrix $A$ and backtracking pointers $B$
\FOR{$p \in \mathcal{P}$}
    \STATE $A[2, p] = S(p; p_s, q)$
    \STATE $B[2, p] = p_s$
\ENDFOR
\FOR{$l=2$ to $L-1$}
    \FOR{$p \in \mathcal{P}$}
        \STATE $A[l+1, p]   = \max_{p' \in \mathcal{P}} \{ A[l, p'] + S(p; p', q) \}$ \label{eq:max}
        \STATE $B[l+1, p]   = \argmax_{p' \in \mathcal{P}} \{ A[l, p'] + S(p; p', q) \}$ \label{eq:argmax}
        %\STATE Compute $A[l+1, p]$ using Equation~(\ref{eq:max})
        %\STATE Compute $B[l+1, p]$ using Equation~(\ref{eq:argmax})
    \ENDFOR
\ENDFOR
% //trace back to find the actual path
\STATE $\mathcal{T}= \{p_e\}$, $l = L$, $p = p_e$
\REPEAT
    \STATE Prepend $B[l, p]$ to $\mathcal{T}$
    \STATE $l = l - 1$, $p = B[l, p]$
\UNTIL{$l < 2$}
\RETURN $\mathcal{T}$
\end{algorithmic}
\end{algorithm}


\secmoveup
\subsection{Avoiding sub-tours} %%LX: walk vs path is never defined! but sub-tour seem to be??
\label{sec:nosubtour}

Trajectories recommended by \textsc{Markov} (Section~\ref{sec:rankplan}) and \textsc{Rank+Markov} (Section~\ref{sec:rank+markov})
are found using the maximum likelihood approach, and may contain multiple visits to the same POI.
This is because the best solution from Viterbi decoding %best path (or walk) from Viterbi decoding %random walk suggested by Viterbi
may have
%tottering (where the Markov chain transitions back and forth between two states), or may have
circular sub-tours (where a POI already visited earlier in the tour is visited again).
We propose a method for eliminating sub-tours by %specifying additional constraints. % when recommending trajectories.
%
%  \item ILP
%In particular, we find the best path using an integer linear program (ILP) with
finding the best path using an integer linear program (ILP),
with sub-tour elimination constraints adapted from the Travelling Salesman Problem~\cite{opt98}.
In particular, given a set of POIs $\mathcal{P}$, the POI-POI transition matrix and a query $q = (p_s, p_e, L)$,
we recommend a trajectory by solving the following ILP:
\eqmoveup
\vspace{-0.3em}
\begin{alignat}{5}
\eqmoveup
& \max_{x,u}  ~&& \sum_{i=1}^{N-1} \sum_{j=2}^N ~x_{ij} ~\log P(p_j | p_i)                                                \nonumber \\
& ~s.t. ~&& x_{ij} \in \{0, 1\}, ~x_{ii} = 0, ~u_i \in \mathbf{Z}, ~\forall i, j = 1, \cdots, N                    \label{eq:cons1} \\
&        && \sum_{j=2}^N x_{1j} = \sum_{i=1}^{N-1} x_{iN} = 1, ~\sum_{i=2}^N x_{i1} = \sum_{j=1}^{N-1} x_{Nj} = 0  \label{eq:cons2} \\
&        && \sum_{i=1}^{N-1} x_{ik} = \sum_{j=2}^N x_{kj} \le 1,   ~\forall k=2, \cdots, N-1                       \label{eq:cons3} \\
&        && \sum_{i=1}^{N-1} \sum_{j=2}^N x_{ij} = L-1,                                                            \label{eq:cons4} \\
&        && u_i - u_j + 1 \le (N-1) (1-x_{ij}),                     \forall i, j = 2, \cdots, N                    \label{eq:cons5}
\end{alignat}
where $N=|\mathcal{P}|$ is the number of available POIs and $x_{ij}$ is a binary decision variable
that determines whether the transition from $p_i$ to $p_j$ %would be allowed 
is in the resulting trajectory.
For brevity, we arrange the POIs such that $p_1 = p_s$ and $p_N = p_e$.
%assume $x_{i1}$ and $x_{1j}$ represent the incoming and outgoing transitions of $p_s$,
%similarly, $x_{iN}$ and $x_{Nj}$ correspond to the incoming and outgoing transitions of $p_e$.
%Constraint $(\ref{eq:cons2})$ restricts that %only one outgoing (incoming) transition for $p_s$ ($p_e$) is permitted, i.e.,
%Constraint $(\ref{eq:cons3})$ restricts that any POI could be visited at most once.
%Constraint $(\ref{eq:cons4})$ restricts that only $L-1$ transitions between POIs are permitted,
Firstly, the desired trajectory should start from $p_s$ and end at $p_e$ (Constraint~\ref{eq:cons2}).
In addition, any POI could be visited at most once (Constraint~\ref{eq:cons3}).
Moreover, only $L-1$ transitions between POIs are permitted (Constraint~\ref{eq:cons4}),
i.e., the number of visited POIs should be exactly $L$ (including $p_s$ and $p_e$).
The last constraint, where $u_i$ is an auxiliary variable,
enforces that only a single sequence of POIs without sub-tours is permitted in the trajectory.
%%LX: mention the implementation, and state the obvious (for new readers)
We solve this ILP using the Gurobi optimisation package~\cite{gurobi}, 
and the resulting trajectory is constructed by tracing the non-zeros in $x$. 
We call our method that uses the POI-POI transition matrix to recommend paths
%that do not have circular sub-tours \textsc{MarkovPath}.
without circular sub-tours \textsc{MarkovPath}.


%Similar to the \textsc{Markov} algorithm (Section~\ref{sec:rankplan}),
Sub-tours in trajectories recommended by \textsc{Rank+Markov} can be eliminated in a similar manner,
we solve an ILP by optimising the following objective 
%Objective~(\ref{eq:obj2}) 
with the same constraints described above,
%we solve an ILP by maximising $\sum_{i=1}^{N-1} \sum_{j=2}^N x_{ij} S(p_j; p_i, q)$ with the same constraints described above.
%simply replace Objective~(\ref{eq:obj}) with \ref{eq:obj2}.
%\vspace{-1.5em}
\eqmoveup
\eqmoveup
\eqmoveup
\vspace{-1em}
\begin{equation}
\label{eq:obj2}
\max_{x,u} \sum_{i=1}^{N-1} \sum_{j=2}^N ~x_{ij} ~S(p_j; p_i, q),
\end{equation}
where $S(p_j;p_i,q)$ incorporates both node ranking and transitions, as defined in Equation~(\ref{eq:combined-score}).
This algorithm is called \textsc{Rank+MarkovPath} in the experiments.
